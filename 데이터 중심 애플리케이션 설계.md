# 1장. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션

과거와 달리 현재는 계산 중심이 아닌 데이터 중심적 애플리 케이션을 만듬

표준 구성 요소: ex) DB, 캐시, 검색 색인, 스트림, 일괄 처리 등등

이런 표준 구성에 대해 각 애플리케이션 마다 요구 사항이 다르기에 구축 시스템 또한 저마다의 특성을 지님(ex DB)

## 데이터 시스템에 대한 생각

데이터 시스템이라는 포괄적인 용어로 묶어야 하는 이유
- 데이터 저장과 처리를 위한 여러 도구들이 전통적인 분류에 딱 들어 맞지 않음(ex: 데이터베이스 처럼 지속성을 제공하는 아파치 카프카, 메시지 큐로 사용하는 데이터 스토어인 레디스 등 )
- 단일 애플리케이션으로는 데이터 처리와 저장 모두를 만족 시킬 수 없고 다양한 도구들을 연결할 필요가 있음

## 신뢰성

- 애플리케이션은 사용자가 기대한 기능을 수행한다

- 시스템은 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법을 허용할 수 있다

- 시스템 성능은 예상된 부하와 데이터 양에서 필수적인 사용 사례를 충분히 만족한다.

- 시스템은 허가되지 않은 접근과 오남용을 방지한다.

위 모든 것이 올바르게 동작함을 의미하며 무언가 잘못되더라도 올바르게 동작함을 신뢰성 의미로 생각할 수 있음

- 결함: 잘못될 수 있는 일 -> 예측하고 대처할 수 있는 시스템을 내결함성 또는 탄력성을 지녔다 표현

- 내결함성을 지녔다고 해서 모든 종류의 결함을 견딜수 있다는 것이 아닌 특정 유형의 결함에 대해 내성을 지녔다고 이야기하는게 타당함

- 장애: 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우 -> 이런 장애가 결함으로 발생하지 않도록 구조를 설계하는 것이 좋음

- 하드웨어 결함
  - 하드웨어 자체 결함으로 MTTF(하드디스크의 평균 장애 시간)은 약 10 ~ 50년으로 보고됨
  - 시스템 장애율을 줄이기 위해 각 하드웨어 구성요소에 중복을 추가함
  - But 데이터 양과 애플리케이션의 계산 요구가 늘어 남에 따라 많은 하드웨어가 사용되어 있고 이에 비례하는 하드웨어 결함율이 증가함
  - 소프트웨어 내결함성 기술을 통해 해당 문제를 해결함

- 소프트웨어 오류
  - 하드웨어의 경우 장비들 관의 오류가 약상관관계를 지님
  - But 소프트웨어 오류의 경우 예상하기 어렵고 오류간 큰 상관관계를 지님
    - 잘못된 특정 입력이 있을 떄 모든 애플리케이션 서버 인스턴스가 죽는 소프트웨어 버그 ex) 리눅스 커널의 버그로 인해 애플리케이션이 일제히 멈췄던 적이 있음
    - 한 구성 요소의 장애가 다른 구성 요소의 장애를 야기하고 차례차례 더 많은 결함이 발생하는 연쇄 장애

- 인적 오류
  - 인적 오류의 경우 전체 결함중 10~25%를 차지함
  - 이런 인적 오류를 줄이는 접근 방식
    - 오류의 가능성을 최소하는 방향으로 시스템을 설계하라.
    - 사람이 가장 많이 실수 하는 부분에서 사람의 실수로 장애가 발생할 수 있는 부분을 분리하라.
    - 단위 테스트부터 전체 시스템 통합 테스트까지 모든 수준에서 철저하게 테스트 수행하라.
    - 장애 발생의 영향을 최소화하기 위해 인적 오류를 빠르고 쉽게 복구할 수 있도록 하라.
    - 성능 지표와 오류율과 같은 상세하고 명확한 모니터링 대책을 마련하라.

## 확장성

증가하는 부하에 대처하는 시스템 능력을 표현하는 용어로 "X는 확장 가능하다" 또는 "Y는 확장 불가능하다"를 의미 하기보다는 "시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가에 대한 질문을 고려한다"는 의미임.

### 부하 기술하기

얼마나 요청을 받는지 설명할 수 있는 지표로 현재 부하를 파악하는게 필요함.

부하 매개변수: 시스템 설계에 따라 달라지며 초당 요청 수, 데이터베이스 읽기 대 쓰기 비율 등등 사용함

트위터 예시
- 트위터 주요 동작은 트윗 작성(사용자가 팔로워에게 새로운 메시지 게시, 평균 초당 4.6k 요청, 피크 시 초당 12k)과 홈 타임라인(사용자가 팔로우한 사람의 작성 트윗을 봄, 초당 300k)
- 문제상황: 개별 사용자가 인기 있는(팔로우가 많은) 사람을 팔로우 하고 인기 있는(팔로우가 많은) 사람이 개별 사용자에게 트윗 작성.
- 방안1. 새로운 트윗이 작성되면 전체 트윗을 모아놓는 테이블에 삽입한다. 사용자가 자신의 홈 타임라인을 요청하면, 팔로우하는 모든 사람을 찾아서 그 사람의 트윗을 시간순으로 결합한다.
- 방안2. 새로운 트윗이 작성되면 사용자를 팔로우하는 모든 사람을 찾아서, 팔로워 각자의 홈 타임라인 캐시에 새로운 트윗을 insert 한다.
- 트위터는 방안 1을 처음 선택했으나 추후에 부하에 의해 방안 2로 전환함
- 그러나 방안 2의 경우 팔로워 수의 사용장에 따라 너무 큰 부하를 요구하기에 팔로워 수에 따라 1과 2를 혼합하게 사용하도록 수정함

### 성능 기술하기

일단 부하 매개변수를 결정하면(cpu 사용량을 보겠다, 초당 TPS 를 확인하겠다 등), 다음 두 가지 방법으로 성능을 측정하여 지표화 할 수 있다.

- 부하 매개변수를 증가시키고 시스템 자원을 변경하지 않고 유지하면 성능은 어떻게 영향을 받을까?
- 부하 매개변수를 증가시켰을 때 성능이 변하지 않고 유지되기를 원한다면 얼마나 많이 자원을 늘려야 할까?

두 질문 모두 성능 수치가 필요하다. 이런 성능 수치는 대표적으로 처리량과 응답시간으로 구성된다

- 처리량: 초당 처리할 수 있는 레코드 수로 하둡과 같은 일괄 처리 시스템이 주로 사용

- 응답시간: 요청시 서버의 응답 시간으로 온라인 시스템에서 주로 사용

  - 지연 시간: 응답 시간과 비슷하게 쓰이지만 응답 시간과 달리 요청이 처리되길 기다리는 휴지 상태인 시간

이중 응답 시간의 경우 매번 동일하지 않기에 분포로 측정해야한다. 이런 응답 시간의 경우 특이 값이 존재 하기에 주로 산술적인 평균 시간을 통해 측정하지만 좋은 지표가 아니다. 따라서 산술적인 평균보다는 백분위 즉 중앙값을 사용하는 것을 추천한다.  중앙값은 50분위로 p50 으로 기술하곤 하는데, 이는 사용자의 절반은 중앙값보다 빠르고, 절반은 느리다는 의미이다. 아마존은 내부 서비스의 응답 시간 요구사항을 p999 로 나타내곤 한다. 이는 요청 1000 개 중에서 가장 느린 한 개의 응답속도를 나타내는 숫자이다.

그런데 이 p999가 꼬리 지연 시간으로 주로 VIP같이 많은 데이터를 사용한 고객의 응답시간일 가능성이 높다. 따라서 이런 고객이 행복하게 하는 것이 판매량에 중대한 영향을 끼치기에 속도개선을 하기 위해 노력한다.

하지만 이런 노력이 과해 p999 보다 소수인 p9999(어쩌면 더 높은 VIP)의 응답속도를 개선하기 위한 최적화 작업의 비용이 너무 많이 들기에 최적화 작업을 수행하지 않는다. 즉 비용적인 측명과 응답시간의 백분위를 고려하여 최적화 작업을 수행한다.

p999 를 최적화해야 하는 다른 이유가 있을까? 큐 대기 지연(queueing delay) 또한 그 이유 중 하나가 될 수 있다. 서버는 병렬로 소수의 작업만 처리할 수 있기 때문에, 소수의 느린 요청 처리만으로도 후속 요청 처리가 지체된다. 이 현상을 선두 차단(head-of-line blocking) 이라 한다.

### 부하 대응 접근 방식

부하 매개변수가 어느 정도 증가하더라도 좋은 성능을 유지하려면 어떻게 해야 할까? 사람들은 확장성을 두 가지로 분리하여 이야기하곤 한다.

- scaling up: 좀 더 강력한 장비로 이동한다.

- scaling out: 다수의 낮은 장비에 부하를 분산한다.

고사양 장비는 보통 매우 비싸기 때문에, 대게 규모 확장이 효율적이다.

일부 시스템은 탄력적(elastic)이다. 즉 부하 증가를 감지하면 컴퓨팅 자원을 자동으로 추가할 수 있다. 반면 그렇지 못한 시스템은 사람이 수동으로 시스템을 확장해주어야 한다. 탄력적인 시스템은 부하를 예측할 수 없을 만큼 높은 경우 유용하지만, 그렇지 못한 경우에는 수동으로 확장하는 시스템이 더 간단하고 운영장 예상치 못한 일이 더 적다.

다수의 장비에 stateless 한 서비스를 배포하는 일은 상당히 간단하다. 하지만 stateful 한 테이터 시스템을 분산하는 일은 매부 복잡하기 때문에, 확장 비용이나 데이터베이스를 분산으로 만들어야 하는 요구가 있기 전까지는 단일 노드에 데이터베이스를 유지하는 것이 최근까지의 통념이다.

다만 최근에는 분산 시스템을 위한 도구와 추상화가 좋아지면서, 이 통념이 적어도 일부 애플리케이션에서는 바뀌었다. 대용량 데이터와 트래픽을 다루지 않는 경우에도 분산 데이터 시스템이 향후 기본 아키텍처로 자리 잡을 가능성이 있다.

대게 대규모로 동작하는 시스템의 아키텍처는 해당 시스템을 사용하는 애플리케이션에 특화되어 있다. 범용적이고 모든 상황에 맞는 확장 아키텍처는 없다. 읽기의 양, 쓰기의 양, 저장할 데이터의 양, 데이터의 복잡도, 응답 시간 요구사항, 접근 패턴 등에 맞추어 아키텍처를 설계하여야 한다.

특정 애플리케이션에 적합한 확장성을 갖춘 아키텍처는 주요 동작이 무엇이고, 잘 하지 않는 동작이 무엇인지에 대한 가정을 바탕으로 구축된다. 이 가정은 곧 부하 매개변수가 된다.

## 유지보수성

소프트웨어의 비용은 대부분 유지보수에 들어간다. 모든 사람은 레거시 시스템을 유지보수하는것을 좋아하지 않는다. 희망적인 점은, 유지보수 중 고통을 최소화할 수 있게 소프트웨어를 설계할 수 있다는 것이다. 그러기 위해서 주의를 기울어야 하는 원칙은 다음과 같다.

- 운용성: 운영팀이 시스템을 원활하게 운영할 수 있게 쉽게 만들어라

- 단순성: 시스템에서 복잡도를 최대한 제거해 새로운 엔지니어가 시스템을 이해하기 쉽게 만들어라

- 발전성: 엔지니어가 이후에 시스템을 쉽게 변경할 수 있게 하라. 그래야 요구사항 변경 같은 예기치 않은 사용 사례를 적용하기가 쉽다. 이 속성은 유연성, 수정 가능성, 적응성으로 알려져 있다.

### 운용성: 운영의 편리함 만들기

좋은 운영성이란 동일하게 반복되는 태스크를 쉽게 수행하게끔 만들어, 운영팀이 고부가가치 활동에 노력을 집중한다는 의미이다. 즉, 동일 반복 태스크를 쉽게 할 수 있게 만들어야 한다.

### 단순성 : 복잡도 관리

프로젝트가 커짐에 따라 시스템은 매우 복잡해지고 이해하기 어려워진다. 복잡도는 다양한 증상으로 나타난다. **상태 공간의 급증, 모듈 간 강한 커플링, 복잡한 의존성, 일관성 없는 명명과 용어, 성능 문제 해결을 목표로 한 해킹, 임시방편으로 문제를 해결한 특수 사례** 등이 이런 증상이다.

개발자가 시스템을 이해하고 추론하기 어려워지면 시스템에 숨겨진 가정과 의도치 않은 결과 및 예기치 않은 상호작용을 간과하기 쉽다. 따라서 시스템은 단순해야 한다.

시스템을 단순하게 만든다는게 반드시 기능을 줄인다는 의미가 아닌 **우발적** 복잡도를 줄인다는 뜻이다. 이 복잡도를 해결하기 위한 취상의 도구는 **추상화**다. 이런 추상화는 큰 시스템의 일부를 잘 정의되고 재사용 가능한 구성 요소로 추출할 수 있게 한다.

### 발전성 : 변화를 쉽게 만들기

시스템의 요구사항은 지속적으로 변화한다. 이 책에서는 다양한 애플리케이션이나 다른 특성을 가진 서비스로 구성된 대규모 데이터 시스템 수준에서 민첩성을 높이는 방법을 찾는다. 데이터 시스템 변경을 쉽게 하는 건 시스템의 간단함과 추상화와 밀접한 관련이 있다. 이해하기 쉬운 시스템은 수정하기 쉽다. 하지만 데이터 시스템 수준에서 민첩성을 언급할 때는 발전성이라는 개념을 따로 사용하겠다.

## 정리

- 애플리케이션이 유용하려면 다양한 요구사항을 충족시켜야 한다.
  - 기능적 요구사항(데이터를 조회, 검색, 처리)
  - 비기능적 요구사항(보안, 신뢰성, 법규 준수, 확장성, 호환성, 유지보수성)
  - 이 장에서는 신뢰성, 확장성, 유지보수성을 살펴보았다.
- 신뢰성
  - 결함이 발생해도 시스템을 올바르게 동작하게 한다.
- 확장성
  - 부하가 증가해도 좋은 성능을 유지하기 위한 전략
- 유지보수성
  - 시스템에서 작업하는 엔지니어와 운영 팀의 삶을 개선한다.
  - 좋은 추상화와 좋은 운용성으로 유지보수성을 증가시킬 수 있다.



# 2장. 데이터 모델과 질의 언어

## 데이터 모델과 질의 언어

데이터 모델은 소프트웨어가 어떻게 작성됐는지 뿐만 아니라, 해결하려는 문제를 **어떻게 생각해야 하는지** 에 대해서도 지대한 영향을 미친다.

대부분의 애플리케이션은 하나의 데이터 모델을 다른 데이터 모델 위에 계층을 둬서 만든다. 각 계층은 다른 계층과 데이터 표현을 통해 소통한다. 예를 들면

- 애플리케이션은 현실 문제를 보고 객체나 데이터 구조, 그리고 API를 모델링 한다.

- 데이터 구조는 JSON, XML, 문서, RDB로 저장된다.

- 위의 데이터 구조들은 네트워크 바이트 단위로 저장되며, 이 바이트를 가지고 데이터를 질의, 탐색, 조작할 수 있다.

기본 개념은 다음과 같다. **각 계층은 명확한 데이터 모델을 제공해 하위 계층의 복잡성을 숨긴다.** 이 추상화는 다른 계층의 사람들이 효율적으로 함께 일 할 수 있게끔 한다.

이런 데이터 모델의 선택은 결국 소프트웨어가 할수 있는 일/ 없는 일에 대한 지대향 영향을 주기에 매우 중요하다.

이 장에서는 다양한 범용 데이터 모델을 살펴본다. 특히 관계형 모델, 문서 모델, 그래프 기반 데이터 모델을 비교한다.

## 관계형 모델과 문서 모델

관계형 데이터베이스의 근원은 1960년대와 70년대에 메인프레임 컴퓨터에서 수행된 비즈니스 데이터 처리에 있다. 보통 트렌젝션 처리와 일괄 처리를 수행하였고, 오늘날에는 일반적인 데이터 처리 방식이다.

수 많은 모델들이 경쟁하였고, 1970년대에는 **네트워크 모델**과 **계층 모델**, 그리고 객체 데이터베이스, XML 데이터베이스가 나타났지만 관계형 데이터베이스는 위의 모델을 모두 무찌르고 현재 웹에서 볼 수 있는 대부분의 서비스에 사용되고 있다.

### NoSQL의 탄생

가장 최근 RDMS에 도전하는 데이터베이스로 다음과 같은 특징이 있다.

- 대규모 데이터셋이나 매우 높은 쓰기 처리량 달성을 관계형 데이터베이스보다 쉽게 할 수 있다
- 상용 데이터베이스 제품보다 무료 오픈소스가 많다.
- 관계형 모델에서 지원하지 않는 특수 질의가 가능하다.
- 동적이고 표현력이 풍부한 데이터 모델을 사용할 수 있다.

애플리케이션이 저마다 요구사항이 다르므로, 가까운 미래에는 관계형 데이터베이스와 요구사항을 충족시킬 수 있는 NoSQL 을 같이 사용하게 될 것이다. 이런 개념을 종종 **다중 저장소 지속성(polyglot persistence)** 라 한다.

### 객체 관계형 불일치

오늘날 대부분의 애플리케이션은 객체지향 프로그래밍 언어인데 반해, SQL 데이터 모델은 그렇지 않다. 따라서 데이터를 저장할 때 전환 계층이 필요하다. 이를 해결하기 위해 액티브레코드나 하이버네이트같은 ORM 프레임워크를 사용하기도 하지만, 두 모델 간의 차이를 완벽히 숨길 수는 없다.

예를 들면 링크드인 프로필을 저장한다고 했을 때, RDBMS 는 여러 테이블을 설계하여 그 테이블 사이의 관계를 가지고 데이터를 표현하게 된다. 

![그림 2-1](.\image\data-intensive-applications\ch2\그림 2-1.png)

하지만, 이력서 같은 데이터 구조는 모든 내용을 갖추고 있는 **문서** 라서, JSON 표현에 매우 적합하다.

```
{
  "user_id":251,
  "first_name": "Bill",
  "last_name": "Gates",
  "summary": "Co-chair of the Bill & Melinda Gates... Active blogger.", 
  "region_id ": "us :91", 
  "industry_id": 131, 
  "photo_unl": "/p/7/000/253/05b/308dd6e.jpg",
  "positions": [ 
    {"job_title": "Co-chair ", "organization": " Bill & Melinda Gates Foundation"}, 
    {"job_title": "Co-founder, Chairman", "organization": "Microsoft"} 
  ], 
  "education": [ 
    {"school_name": " Harvard University ", "start": 1973, "end": 1975}, 
    {"school_name": "Lakeside School, Seattle", "start": null, "end": null} 
  ], 
  "contact_info": { 
    "blog": "http://thegatesnotes .com", 
    "twitter": "http:/Itwitter.comlBillGates" 
  }
 }
```

JSON 표현은 RDBMS 의 다중 테이블 스키마보다 더 나은 **지역성**을 갖는다. 관계형 테이블에서는 프로필을 가져오려면 여러 쿼리를 날리던지, 난잡한 다중 조인을 수행하여야 한다. JSON 모델은 모든 관련 정보가 한 곳에 있어, 질의 하나로 충분하다. 또한 사용자 프로필에서 직위, 학력 기록, 연락처 정보는 의미상 1:N 관계이다. 즉, 사용자 251은 N개의 직업을 가졌고, N 개의 학력이 있는 것이다.

### 다대일과 다대다 관계

위의 예제에서 region_id 와 industry_id 는 평문이 아니라 id 로 주어졌다. 평문이 아니라 아이디로 저장하면 다음과 같은 이점이 있다.

- 프로필 간 일관된 스타일과 철자
- 모호함 회피
- 갱신의 편의성
- 현지화 지원
- 더 나은 검색

핵심적인 것은 중복의 문제이다. ID 를 사용하는 경우, 사람에게 의미 있는 정보는 한 곳에만 저장하고 그것을 참조하는 모든 것은 ID 를 사용한다. ID 는 아무 의미가 없기 때문에, 식별 정보를 변경하여도 ID 는 동일하게 유지할 수 있다. 만약 정보가 중복되어 있다면, 정보 갱신시에 모든 정보를 갱신하여야 한다. 이것은 **쓰기 오버헤드와 불일치(일부 정보만 갱신됨)** 를 불러일으킬 위험이 있다.

중복된 데이터를 정규화하려면 RDBMS 처럼 many-to-one 관계가 필요한데, 이는 문서 모델에는 적합하지 않다.  그 이유는 문서 데이터베이스에서는 조인에 대한 지원이 약하기에 애플리케이션에서 조인을 흉내내야한다. 또한 애플리케이션에 점점 기능을 추가하면 할수록, 데이터 사이에 상호 연결되는 경향 즉, 관계가 발생하게 된다.

- 추천서 : 한 사용자가 다른 사용자를 추천한다고 가정하자. 추천받은 사용자의 추천서에서는 추천인의 이름과 사진을 확인할 수 있다. 추천인이 자신의 사진을 갱신하면 모든 추천서에도 사진이 갱신되어야 한다. 즉, 추천서는 추천인의 프로필을 참조한다.

![그림 2-2](.\image\data-intensive-applications\ch2\그림 2-2.png)